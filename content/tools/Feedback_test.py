"""
	Code to give automated feedback on TheMulQuaBio computing practical work.  

	USAGE 
	
	python3 Feedback.py StudentsFile RepoPath Week

	or, if ready to git push: 
	
	python3 Feedback.py StudentsFile RepoPath Week --gitpush 

	example: python3 Feedback.py ~/Documents/Teaching/IC_CMEE/2021-22/Students/Students.csv ~/Documents/Teaching/IC_CMEE/2021-22/Coursework/StudentRepos Week1

	ARGUMENTS: 

	StudentsFile  : FULL path to input file containing student data, including 					git repo address
	RepoPath 	  : FULL path to location for students' local git repositories 					(without an ending "/")
	Week		  : Name of week to give feedback on (Week1, Week2, etc.)						(case insensitive)
 
    --gitpull 	  : Optional flag indicating whether to pull students' git 					    repositories only without feedback (default is False). 					    If the student's repo does not already exist locally, it 					will be cloned from the remote address.
 
    --gitpush     : Optional flag indicating whether to rgenerate the feedback 					and push the feedback log file(s) to students' git 							repositories (default is False).

	--gitpush_fin : Optional flag indicating whether to push the final feedback 				to students' git repositories (default is False). If used, 					repo is updated from remote and contents of feedback 						directory pushed, nothing else.

	--no_git	  : Optional flag to disable GitHub activity. Default is 						 False.

	--clean_up	  : Optional flag to indicate whether the script should erase 					 all outputs generated by tested scripts. Default is false.
"""

################ Imports #####################

import subprocess, os, csv, argparse, re, time

################ Functions #####################
def run_popen(command, timeout):
	""" 
	Runs a sub-program in subprocess.Popen using the given COMMAND and
	TIMEOUT (seconds). Requires the `time` module. 
	"""

	start = time.time()

	p = subprocess.Popen('timeout ' + str(timeout) + 's ' + command, shell=True, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)

	try:
		stdout, stderr = p.communicate(timeout=timeout)
	except subprocess.TimeoutExpired:
		p.kill()
		stdout, stderr = p.communicate()
	
	end = time.time()
	
	return p, stdout.decode(), stderr.decode(), (end - start) # decode: binary --> string

################ Initializations #####################
#~ Initialize list of expected files, on a per week basis

if args.Week.lower() == 'week1' :
	expectedFiles = ['boilerplate.sh', 'CompileLatex.sh', 'ConcatenateTwoFiles.sh', 'CountLines.sh', 'csvtospace.sh', 'FirstBiblio.bib', 'FirstExample.tex', 'MyExampleScript.sh', 'tabtocsv.sh', 'tiff2png.sh', 'UnixPrac1.txt', 'variables.sh'] 
if args.Week.lower() == 'week2' :
	expectedFiles = ['align_seqs.py', 'align_seqs_better.py', 'align_seqs_fasta.py', 'basic_csv.py', 'basic_io1.py', 'basic_io2.py', 'basic_io3.py', 'boilerplate.py', 'cfexercises1.py', 'cfexercises2.py', 'control_flow.py', 'debugme.py', 'dictionary.py', 'lc1.py', 'lc2.py', 'loops.py', 'oaks.py', 'oaks_debugme.py', 'scope.py', 'sysargv.py', 'test_control_flow.py', 'tuple.py', 'using_name.py'] 
if args.Week.lower() == 'week3' :
	expectedFiles = ['apply1.R', 'apply2.R', 'ANOVA_Prac.R', 'basic_io.R', 'boilerplate.R', 'break.R', 'browse.R', 'control_flow.R', 'DataWrang.R', 'DataWrangTidy.R', 'ExpDesign.R', 'Ftests.R', 'get_TreeHeight.py', 'get_TreeHeight.R', 'Girko.R', 'GPDD_Data.R', 'Interactions.R', 'MyGLM.R', 'MulExpl.R', 'MyBars.R', 'MyModelSimp.R', 'next.R', 'plotLin.R', 'PP_Dists.R', 'PP_Regress_loc.R', 'PP_Regress.R', 'preallocate.R', 'R_conditionals.R', 'Regression.R', 'Ricker.R', 'run_get_TreeHeight.sh', 'sample.R', 'SQLinR.R', 'TAutoCorr.R', 'TAutoCorr.tex', 'TreeHeight.R', 'try.R', 'ttests.R', 'Vectorize1.py', 'Vectorize1.R', 'Vectorize2.py', 'Vectorize2.R']   # optionally include a 'vectorize_timer.sh'?
if args.Week.lower() == 'week7' :
	expectedFiles = ['blackbirds.py', 'DrawFW.py', 'fmr.R', 'LV1.py', 'LV2.py', 'LV3.py', 'LV4.py', 'Nets.R', 'Nets.py', 'profileme2.py', 'profileme.py', 're4.py', 'regexs.py', 'run_fmr_R.py', 'run_LV.py', 'TestR.py', 'TestR.R', 'timeitme.py', 'using_os.py'] # could include 'MyFirstJupyterNb.ipynb'

################## Main Code #####################

# set up the argument parser 
parser = argparse.ArgumentParser("Gives Automated Feedback on CMEE Masters weekly computing practical work")

# positional argument inputs
parser.add_argument("StudentsFile", help="Input file containing student details (full path)")
parser.add_argument("RepoPath", help="Location for git repositories (full path)")
parser.add_argument("Week", help="Name of week to give feedback on (Week1, Week2, etc.)")

# Optional argument inputs
parser.add_argument("--gitpull", action="store_true", 
								 dest="gitpull", default=False,
								 help="Whether to only git pull (no feedback) repositories")

parser.add_argument("--gitpush", action="store_true", 
								dest="gitpush", default=False,
								help="Whether to re-run and send feedback to students' git repositories")

parser.add_argument("--gitpush_fin", action="store_true", 
								dest="gitpush_fin", default=False,
								help="Whether to push final feedback to students' git repositories")

parser.add_argument("--no_git", action="store_true",
								dest="no_git", default=False,
								help="Optionally disables all Git functionality of the program. Useful for markers" )

parser.add_argument("--clean_up", action="store_true",
								dest="clean_up", default=False,
								help="Optionally removes output generated by student scripts. Useful for markers who are running the code multiple times!" )

# import ipdb; ipdb.set_trace()

args = parser.parse_args()

with open(args.StudentsFile,'r') as f: # Read in and store the student data
	csvread = csv.reader(f)
	Stdnts = [tuple(row) for row in csvread]

Hdrs = Stdnts[0] #store headers
Stdnts.remove(Hdrs) #remove header row 

scrptPath = os.path.dirname(os.path.realpath(__file__)) #store feedback script path
timeout = 30 #set time out for each script's run (integer seconds)
charLim = 500 #set limit to output of each script's run to be printed

for Stdnt in Stdnts:
	
	Name = (Stdnt[Hdrs.index('First_name')] + Stdnt[Hdrs.index('Second_name')]+ '_' + Stdnt[Hdrs.index('Username')]).replace(" ","").replace("'","") #Remove any spaces from name
	print(Name)
	RepoPath = args.RepoPath + '/' + Name
	print(RepoPath)
	AzzPath = RepoPath + '/Feedback'
	
	Points = 100
	totime = 0

	if args.no_git == False:

		if args.gitpush_fin: # Push the final feedback...
			
			print("...\n\n" + "Git pushing final feedback for " + Stdnt[Hdrs.index('First_name')] + " "+ Stdnt[Hdrs.index('Second_name')] + "...\n\n")

			subprocess.check_output(["git","-C", RepoPath, "add", os.path.basename(AzzPath) + "/*"])

			subprocess.check_output(["git","-C", RepoPath, "commit","-m","Pushed final feedback"])

			subprocess.check_output(["git","-C", RepoPath,"push", "origin", "HEAD"])

			continue # ...and skip the rest

		if not os.path.exists(RepoPath): # Clone repo if it does not already exist
			
			print("...\n\n"+"Student's repository does not exist; Cloning it...\n\n")
			
			subprocess.check_output(["git","clone", Stdnt[Hdrs.index('GitRepo')], RepoPath])
		
		else: # otherwise update the existing repo

			print("...\n\n"+"Updating git repository of "+ Stdnt[Hdrs.index('First_name')] + " "+ Stdnt[Hdrs.index('Second_name')] + "...\n\n")
			
			subprocess.check_output(["git", "-C", RepoPath, "pull"]) # or,
			subprocess.check_output(["git","-C", RepoPath, "fetch","--all"])
			subprocess.check_output(["git","-C", RepoPath, "reset","--hard"]) # discard all local changes
			subprocess.check_output(["git","-C", RepoPath, "clean","-fd"]) # remove untracked files
			print(RepoPath)
			if args.gitpull: continue # Just update the git repo and skip to next student

			p, output, err, time_used = run_popen("git -C " + RepoPath + " count-objects -vH", timeout)
			print(output)

			Keys = list([row.split(': ')[0] for row in output.splitlines()])
			print(Keys)
			Vals = list([row.split(': ')[1] for row in output.splitlines()])
			
			RepoStats = dict(zip(Keys, Vals))

			# print(RepoStats)
			########## block for accessing git log - to be finished ########### 
			## Store git code, along with the corresponding field names in two lists:
			# GIT_COMMIT_FIELDS = ['id', 'author_name', 'author_email', 'date', 'message']
			# GIT_LOG_FORMAT = ['%H', '%an', '%ae', '%ad', '%s']
			##join the format fields together with "\x1f" (ASCII field separator) and delimit the records by "\x1e" (ASCII record separator)
			# GIT_LOG_FORMAT = '%x1f'.join(GIT_LOG_FORMAT) + '%x1e' 
			# p, log, err, time_used = run_popen('git log --format="%s"', timeout)
			# (log, _) = p.communicate()
			# log = log.strip('\n\x1e').split("\x1e")
			# log = [row.strip().split("\x1f") for row in log]
			# log = [dict(zip(GIT_COMMIT_FIELDS, row)) for row in log]
			###################################################################
	else:
		print("No git option selected. \n Running script without connecting to repos.")

		print("...\n\n"+"Getting data on git repository of "+ Stdnt[Hdrs.index('First_name')] +
			 								" "+ Stdnt[Hdrs.index('Second_name')] + "...\n\n")	

		p, output, err, time_used = run_popen("git -C " + RepoPath + " count-objects -vH", timeout)
		print(output)

		Keys = list([row.split(': ')[0] for row in output.splitlines()])
		print(Keys)
		Vals = list([row.split(': ')[1] for row in output.splitlines()])
		RepoStats = dict(zip(Keys, Vals))
		print(RepoStats)
	#~ Now open feedback directory inside repository:	

	if not os.path.exists(AzzPath):
		os.makedirs(AzzPath)
	
	#~ Open feedback log file:

	azzFileName = args.Week + '_' + 'Feedback'+ '_' + time.strftime("%Y%m%d") + '.txt'
	azz = open(AzzPath + '/'+ azzFileName,'w+')
	print('='*70 + '\n' + 'Starting code feedback for '+ Stdnt[Hdrs.index('First_name')] + ' ' + Stdnt[Hdrs.index('Second_name')]+ ', ' + args.Week +'\n' + '='*70 + '\n\n')

	azz.write('Starting code feedback for '+ Stdnt[Hdrs.index('First_name')] + ', ' + args.Week +'\n\n')
	azz.write('Current Points = ' + str(Points) + '\n\n')
	azz.write('Note that: \n')
	azz.write('(1) Major sections begin with a double "====" line \n')
	azz.write('(2) Subsections begin with a single "====" line \n')
	azz.write('(3) Code output or text file content are printed within single "*****" lines \n\n')

	####################################################
	azz.write('='*70 + '\n')
	azz.write('='*70 + '\n')
	
	import ipdb; ipdb.set_trace()

	azz.write('Your Git repo size currently is about ' + RepoStats['size-pack'] +' on disk \n\n')

	azz.write('PART 1: Checking project workflow...\n\n')
	DirCont = os.listdir(RepoPath)
	TempDirs = [name for name in DirCont if os.path.isdir(RepoPath+'/' + name)]
	TempFiles = [name for name in DirCont if os.path.isfile(RepoPath+'/' + name)]
	azz.write('Found the following directories in parent directory: '\
	 + ', '.join(TempDirs) + '\n\n')
	azz.write('Found the following files in parent directory: '\
	 + ', '.join(TempFiles) + '\n\n')

	#~ Begin feedback:
	azz.write('Checking for key files in parent directory...\n\n')
	if '.gitignore' in TempFiles:
		azz.write('Found .gitignore in parent directory, great! \n\n')
		azz.write('Printing contents of .gitignore:\n')
		g = open(RepoPath + '/.gitignore', 'r')
		azz.write('\n' + '*'*70 + '\n')
		for line in g:
			azz.write(line,)
		azz.write('\n' + '*'*70 + '\n\n')
	else:
		azz.write('.gitignore missing, 1 pt deducted\n\n')
		Points = Points - 1
		azz.write('Current Points = ' + str(Points) + '\n\n')
		
	readme = 'n'
	for name in TempFiles:
		if 'readme' in name.lower() and not '~' in name.lower():
			azz.write('Found README in parent directory, named: ' + name + '\n\n')
			azz.write('Printing contents of ' + name + ':' + '\n')
			g = open(RepoPath + '/' + name, 'r')
			azz.write('\n' + '*'*70 + '\n')
			for line in g:
				azz.write(line,)
			azz.write('\n' + '*'*70 + '\n\n')
			readme = 'y'
			break
	if readme == 'n':
		azz.write('README file missing, 1 pt deducted\n\n')
		Points = Points - 1
		azz.write('Current Points = ' + str(Points) + '\n\n')
		
	azz.write('='*70 + '\n')
	azz.write('Looking for the weekly directories...' + '\n\n') 

	WeekDirs = [name for name in TempDirs if 'week' in name.lower()]
	
	WeekDirs.sort()

	if not WeekDirs: #If weekly directories were missing
		azz.write('Weekly directories missing, cannot continue with feedback!\n\n')
		azz.close()
		continue
	else:
		azz.write('Found '+ str(len(WeekDirs)) +\
		' weekly directories: ' + ', '.join(WeekDirs) + '\n\n')
		azz.write('The '+ args.Week +' directory will be assessed \n\n')

	####################################################
	azz.write('='*70 + '\n')
	azz.write('='*70 + '\n')
	azz.write('PART 2: Checking weekly code and workflow...\n\n')
	
	for week in WeekDirs:
		if not args.Week.lower() in week.lower().replace(" ", ""):
			continue # only assess for current week - no week 10 and 1, for eg
		if week.lower() != args.Week.lower(): # This shouldn't be needed to prevent week1 also marking week10, but it is? Odd.
			continue # should probably really refactor the above two statements into one...
		azz.write('='*70 + '\n')
		WeekPth = RepoPath+'/'+week
		azz.write('Assessing ' + week.upper()+'...\n\n')
		DirCont = os.listdir(WeekPth)
		TempDirs = [name for name in DirCont if os.path.isdir(WeekPth +'/' + name)]
		TempFiles = [name for name in DirCont if os.path.isfile(WeekPth +'/' + name)]
		
		azz.write('Found the following directories: '\
		 + ', '.join(TempDirs) + '\n\n')
		azz.write('Found the following files: '\
		 + ', '.join(TempFiles) + '\n\n')
		 
		azz.write('Checking for readme file in weekly directory...\n\n')
		readme = 'n'
		for name in TempFiles:
			if 'readme' in name.lower() and not '~' in name.lower():
				azz.write('Found README in parent directory, named: ' + name + '\n\n')
				azz.write('Printing contents of ' + name + ':' + '\n')
				g = open(WeekPth + '/' + name, 'r')
				azz.write('\n' + '*'*70 + '\n')
				for line in g:
					azz.write(line,)
				g.close()
				azz.write('\n' + '*'*70 + '\n\n')
				readme = 'y'
				break
		if readme == 'n':
			azz.write('README file missing, 1 pt deducted\n\n')
			Points = Points - 1
			azz.write('Current Points = ' + str(Points) + '\n\n')
		
		CodDir = [name for name in TempDirs if 'code' in name.lower()]
		DatDir = [name for name in TempDirs if 'data' in name.lower()]
		ResDir = [name for name in TempDirs if 'result' in name.lower()]
		if not CodDir: 
			azz.write('Code directory missing!\n')
			azz.write("Aborting this week's feedback!\n\n")
			break

		if not DatDir: azz.write('Data directory missing!\n\n')

		if not ResDir: 
			azz.write('Results directory missing!\n\n')
			azz.write('Creating Results directory...\n\n')
			os.makedirs(WeekPth+'/Results')
		else:
			ResNames = []
			for root, dirs, files in os.walk(WeekPth + '/' + ResDir[0]):
				for file in files:
					if not file.startswith("."):
						ResNames.append(file)
			if len(ResNames)>0:
					azz.write('Found following files in results directory: ' + ', '.join(ResNames) + '...\n\n')					
					azz.write('Ideally, Results directory should be empty other than, perhaps a .gitkeep. \n\n')
					Points = Points - len(ResNames)*0.5 
					azz.write(' 0.5 pts deducted per results file \n\n')
					azz.write('Current Points = ' + str(Points) + '\n\n')
			else: 
				azz.write('Results directory is empty - good! \n\n')		
		
		## Now get all code file paths for testing
		Scripts = []
		ScriptNames = []
		for root, dirs, files in os.walk(WeekPth + '/' + CodDir[0]):
			for file in files:
				
				if file.lower().endswith(('.sh','.py','.ipynb','.r','.txt','.bib','.tex')) and not file.startswith(".") :
					 Scripts.append(os.path.join(root, file))
					 ScriptNames.append(file) 
		
		# just making sure both comparisons are identical (so only truly missing / extra files are found)
		for i in range(len(ScriptNames)):
			ScriptNames[i] = ScriptNames[i].lower()

		for i in range(len(expectedFiles)):
			expectedFiles[i] = expectedFiles[i].lower()
		# comparison to expected scripts list.
		extraScripts = []
		for name in ScriptNames:
			if name.lower() not in expectedFiles:
				extraScripts.append(name)
		if len(extraScripts) > 0:
			azz.write('Extra scipt(s) / misspelling(s): ' + ', '.join(extraScripts	) + '\n\n')
		missingScripts = []
		for name in expectedFiles: 
			if name.lower() not in ScriptNames:
				missingScripts.append(name)
		if len(missingScripts) > 0:
			azz.write('Missing script(s): ' + ', '.join(missingScripts) + '\n\n')

		# Get the names of all files in directory before running. Hold for end comparision for garbage removal (useful if running multiple times in a day)
		# e.g. for testing this script. Could also be used for more comprehensive comparison i.e. correct data files + dirs like sandbox included
		AllFiles = []
		AllFileNames = []
		for root, dirs, files in os.walk(WeekPth + '/'):
			for file in files:
				AllFiles.append(os.path.join(root, file))
				AllFileNames.append(file)

		azz.write('Found ' + str(len(Scripts)) + ' code files: ' + ', '.join(ScriptNames) + '\n\n')

		# add a dict here of all scripts / data / etc which should be present, write into file if any missing via comparison

		files = [fname for fname in files if not fname.startswith(".")] # all files except hidden/ghost files
		if len(ScriptNames) < len(files):
			extras = list(set(files) - set(ScriptNames))
			# extras = [name for name in extras if not (name.lower().endswith(('~', 'pyc')))] #ignore certain extensions
			azz.write('Found the following extra files: ' + ', '.join(extras) + '\n')
			Points = Points - .5 * len(extras)
			azz.write('0.5 pt deducted per extra file\n\n')
			azz.write('Current Points = ' + str(Points) + '\n\n')

		## Now test all valid script files that were found
		azz.write('='*70 + '\n')
		azz.write('Testing script/code files...\n\n')
		
		errors = 0 #error counter
		for name in Scripts:
			## cd to current script's directory
			os.chdir(os.path.dirname(name))								
			
			azz.write('='*70 + '\n')

			azz.write('Inspecting script file ' + os.path.basename(name) + '...\n\n')
			azz.write('File contents are:\n')
			azz.write('\n' + '*'*70 + '\n')
						
			g = open(os.path.basename(name), 'r')
			for line in g:
				azz.write(line,)
			g.close()
			azz.write('\n' + '*'*70 + '\n\n')

			azz.write('Testing ' + os.path.basename(name) + '...\n\n')
			print('Testing ' + os.path.basename(name) + '...\n\n')
						
			if os.path.basename(name).lower().endswith('.sh'):
				p, output, err, time_used = run_popen('bash ' + os.path.basename(name), timeout)
			elif os.path.basename(name).lower().endswith('.py'):
				azz.write(os.path.basename(name) + ' is a Python script file;\n\nchecking for docstrings...\n\n')
				with open(os.path.basename(name)) as f:
					funcs = re.findall(r'def\s.+:',f.read(),re.MULTILINE)
				with open(os.path.basename(name)) as f:
					dstrngs = re.findall(r'"""[\w\W]*?"""',f.read(),re.MULTILINE)
					
					if len(funcs)>0 and len(dstrngs)>0:
						azz.write('Found one or more docstrings and functions\n\n')
						if len(dstrngs) < len(funcs) + 1:
							azz.write('Missing docstring, either in one or functions and/or at the script level\n')
							Points = Points - (len(funcs) + 1 - len(dstrngs)) * 0.5
							azz.write('\n')
					elif len(funcs)>0 and len(dstrngs)==0:
						azz.write('Found one or more functions, but completely missing docstrings\n')
						Points = Points - 2 - len(funcs)*0.5 
						azz.write('2 pts deducted for missing docstring for script, and .5 pt deducted per missing docstring for function\n\n')
					elif len(funcs)==0 and len(dstrngs)==1:
						azz.write('Found no functions, but one docstring for the script, good\n\n')
					elif len(funcs)==0 and len(dstrngs)>2:
						azz.write('Found too many docstrings.  Check your script.\n\n')
					else:
						azz.write('No functions, but no script-level docstring either\n')
						Points = Points - 2
						azz.write('2 pts deducted\n\n')

				azz.write('Current Points = ' + str(Points) + '\n\n')

				p, output, err,	time_used = run_popen('python3 ' + os.path.basename(name), timeout)
			
			elif os.path.basename(name).lower().endswith('.r'):
				p, output, err,	time_used = run_popen('/usr/lib/R/bin/Rscript ' + os.path.basename(name), timeout)
			elif os.path.basename(name).lower().endswith('.tex'):
				p, output, err,	time_used = run_popen('bash ~/Documents/Code_n_script/Bash/CompiLatex.sh ' + os.path.basename(name), timeout)
			else:
				os.chdir(scrptPath)
				continue

			chars = 0
						
			azz.write('Output (only first ' + str(charLim) + ' characters): \n\n')
			azz.write('\n' + '*'*70 + '\n')			 
			for char in output:
				print(char), # use end = '' to removes extra newline in python 3.xx
				subprocess.sys.stdout.flush()
				azz.write(char,)
				chars += 1
				if chars > charLim: # Limit the amount of output
					break
			
			azz.write('\n' + '*'*70 + '\n')
			if not err:
				azz.write('\nCode ran without errors or warnings\n\n')
				azz.write('Time consumed = ' +"{:.5f}".format(time_used)+ 's\n\n')
			else:
				errors += 1
				azz.write('\nEncountered error or warning:\n')
				azz.write(err)
				azz.write('\n')
			
			totime += time_used
			
			print('\nFinished with ' + os.path.basename(name)+  '\n\n')
			os.chdir(scrptPath)
		
		if args.clean_up == True :# delete all files generated by run
			EndFiles = []
			EndFileNames = []
			for root, dirs, files in os.walk(WeekPth + '/'):
				for file in files:
					if file not in AllFileNames :
						toRemove = os.path.join(root, file)
						os.remove(toRemove) # need to have 'dir' in there 
				
	azz.write('='*70 + '\n')
	azz.write('='*70 + '\n')
	azz.write('Finished running scripts\n\n')
	azz.write('Ran into ' + str(errors)+' errors or warnings\n\n')
	azz.write('Total time used: ' + "{:.2f}".format(totime)+ 's \n\n')
	azz.write('='*70 + '\n')
	azz.write('\nFINISHED WEEKLY ASSESSMENT\n\n')
	azz.write('Current Points for the Week = ' + str(Points) + '\n\n')
	azz.write('NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!')
	
	azz.close()
			
	if args.gitpush:
		print("Git pushing...\n")
		
		subprocess.check_output(["git","-C", RepoPath, "add", os.path.basename(AzzPath) + "/*"]) # Add only feedbacks/logs
		
		subprocess.check_output(["git","-C", RepoPath, "commit", "-m", 'Pushed ' + args.Week + ' feedback'])
				
		subprocess.check_output(["git","-C", RepoPath,"push", "origin", "HEAD"])
